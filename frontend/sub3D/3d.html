<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3Dネットワークグラフ</title>
  <link rel="stylesheet" href="../main2D/style.css">
  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background: #181a1b;
    }
    #3d-graph {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      background: #181a1b;
      z-index: 1;
      pointer-events: none !important;
    }
    #3d-graph canvas {
      pointer-events: none !important;
    }
    #flashcard-select-controls, #flashcard-select-controls * {
      pointer-events: auto !important;
      z-index: 99999 !important;
    }
    #flashcard-select-controls {
      position: fixed !important;
      z-index: 99999 !important;
    }
    .add-word-section {
      position: relative;
    }
    #add-word-suggestions {
      position: absolute;
      left: 0;
      right: 0;
      top: 100%;
      z-index: 99999;
      background: #22252a;
      color: #fff;
      border: 1px solid rgba(247, 200, 115, 0.2);
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      padding: 0;
      margin-top: 4px;
    }
  </style>
  <script src="//unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="//unpkg.com/three-spritetext@1.6.3"></script>
  <script src="//unpkg.com/3d-force-graph@1.70.7"></script>
</head>
<body>
  <button id="view-2d" class="corner-btn" style="position: fixed; bottom: 2rem; right: 2rem; left: auto; margin: 0; z-index: 1001;" onclick="window.location.href='../main2D/index.html'">2D表示</button>

  <div id="search-container">
    <div id="search-box">
      <input type="text" id="search-input" placeholder="単語を検索..." autocomplete="off">
      <button id="search-btn">
        <svg width="22" height="22" viewBox="0 0 22 22" fill="none" xmlns="http://www.w3.org/2000/svg">
          <circle cx="10" cy="10" r="7" stroke="#f7c873" stroke-width="2"/>
          <line x1="16" y1="16" x2="20" y2="20" stroke="#f7c873" stroke-width="2" stroke-linecap="round"/>
        </svg>
      </button>
      <button id="clear-search-btn" class="hidden">&times;</button>
    </div>
    <div id="search-results" class="hidden">
      </div>
  </div>

  <div id="3d-graph"></div>

  <div id="flashcard-select-controls" class="hidden">
    <div class="edit-panel-header">
      <h3>単語帳作成</h3>
    </div>
    <div class="selected-words-container">
      <div class="selected-words-section">
        <h4>選択された単語</h4>
        <div id="selected-words-list">
          </div>
      </div>
      <div class="add-word-section">
        <h4>単語を追加</h4>
        <input type="text" id="add-word-input" placeholder="単語を検索して追加...">
      </div>
      <div class="edit-panel-name-input">
        <label for="flashcard-name">単語帳の名前:</label>
        <input type="text" id="flashcard-name" placeholder="例: 基礎単語帳" maxlength="50">
      </div>
      <div class="edit-panel-buttons">
        <button id="create-flashcard-select" class="edit-btn">作成</button>
        <button id="cancel-flashcard-select" class="edit-btn">キャンセル</button>
      </div>
    </div>
  </div>

  <!-- Move the suggestions dropdown to the end of body -->
  <div id="add-word-suggestions" class="hidden"></div>

  <div id="details-overlay" class="hidden">
    <div id="details-box">
      <button id="close-details">&times;</button>
      <h3 id="details-title"></h3>
      <p id="details-text"></p>
    </div>
  </div>

  <div class="corner-btn-group visible">
    <button id="zoom-out-btn" class="corner-btn">全体表示</button>
    <button id="view-flashcards" class="corner-btn" onclick="window.location.href='../flashcard/flashcard_menu.html'">単語帳一覧</button>
    <button id="create-flashcards" class="corner-btn">単語帳作成</button>
  </div>

  <script>
    let graphInstance = null;
    const selectedNodes = new Set();
    
    const clearGlow = () => {
        selectedNodes.forEach(node => {
            if (node.__threeObj) {
                ['glow', 'softGlow'].forEach(name => {
                  const obj = node.__threeObj.children.find(child => child.name === name);
                  if (obj) node.__threeObj.remove(obj);
                });
            }
        });
        selectedNodes.clear();
    };
    
    const addGlow = (node) => {
        if (!node || !node.__threeObj) return;
        const glow = new THREE.Mesh(
          new THREE.SphereGeometry(7, 32, 32),
          new THREE.MeshBasicMaterial({
            color: '#ffe066',
            transparent: true,
            opacity: 0.35,
            depthWrite: false
          })
        );
        glow.name = 'glow';
        node.__threeObj.add(glow);
    };

    fetch('/api/data')
      .then(res => {
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        return res.json();
      })
      .then(data => {
        console.log('Data loaded successfully:', data);
        function getColorFromImportance(importance) {
          const clampedImportance = Math.max(0, Math.min(100, importance));
          const ratio = clampedImportance / 100;
          const r = Math.round(180 + (75 * ratio));
          const g = Math.round(120 + (135 * ratio));
          const b = Math.round(60 + (195 * ratio));
          return `rgb(${r}, ${g}, ${b})`;
        }

        const graphData = {
          nodes: data.nodes.map(n => ({
            id: n.id,
            name: n.label,
            label: n.label, // <-- labelプロパティが存在することを確認
            val: n.importance || 1,
            category: n.category || '',
            color: getColorFromImportance(n.importance || 50),
            details: n.details || ''
          })),
          links: data.edges.map(e => ({ source: e.from, target: e.to }))
        };

        const starColors = ['#fffbe6', '#ffeedd', '#b5e3ff', '#7ecfff', '#fff', '#ffd6e6', '#ffe4b5', '#c7eaff'];

        function stripParenthesisContent(label) {
          return label.replace(/\s*\(.*?\)/g, '').replace(/\s*（.*?）/g, '');
        }

        graphInstance = ForceGraph3D()(document.getElementById('3d-graph'))
          .graphData(graphData)
          .nodeThreeObject(node => {
            const sphere = new THREE.Mesh(
              new THREE.SphereGeometry(4, 16, 16),
              new THREE.MeshBasicMaterial({ color: node.color })
            );
            const label = stripParenthesisContent(node.name);
            const sprite = new SpriteText(label);
            sprite.fontWeight = 'bold';
            sprite.material.depthWrite = false;
            sprite.color = node.color;
            sprite.textHeight = 3;
            sprite.position.y = 10;
            const group = new THREE.Group();
            group.add(sphere);
            group.add(sprite);
            return group;
          })
          .nodeThreeObjectExtend(false)
          .nodeLabel(() => '')
          .nodeColor(node => node.color)
          .linkOpacity(0.35)
          .linkColor(() => '#444')
          .linkWidth(() => 2)
          .backgroundColor('#181a1b')
          .onNodeClick(node => {
              if (isSelectingFlashcards) { // 選択モードかどうかをチェック
                  // ロジックはsetup3DNodeSelectionに移動
              } else {
                  clearGlow();
                  if (node) selectedNodes.add(node);
                  addGlow(node);
                  const distance = 40;
                  const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
                  graphInstance.cameraPosition(
                      { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                      node,
                      2000
                  );
              }
          })
          .onBackgroundClick(() => {
            if (!isSelectingFlashcards) clearGlow();
          });

        graphInstance.cameraPosition({ x: 0, y: 0, z: 200 }, { x: 0, y: 0, z: 0 }, 0);
        graphInstance.controls().target.set(0, 0, 0);
        graphInstance.controls().update();

      })
      .catch(error => {
        console.error('Error loading data:', error);
        document.getElementById('3d-graph').innerHTML = `<div style="padding: 20px; color: #f7c873; text-align: center;"><h3>データの読み込みに失敗しました</h3><p>${error.message}</p></div>`;
      });
      
    document.querySelector('.corner-btn-group').classList.add('visible');

  </script>
  <script>
    // --- 3Dビュー機能統合（2Dから移植） ---
    let nodes = [];
    let edges = [];
    let selectedNodeIds = [];
    let isSelectingFlashcards = false;
    let searchResultsArray = [];
    let currentSearchIndex = -1;
    let graphDataCache = null;

    const zoomOutBtn = document.getElementById('zoom-out-btn');
    const searchInput = document.getElementById('search-input');
    const createFlashcardsBtn = document.getElementById('create-flashcards');
    const selectControls = document.getElementById('flashcard-select-controls');
    const cancelSelectBtn = document.getElementById('cancel-flashcard-select');
    const selectedWordsList = document.getElementById('selected-words-list');
    
    if (cancelSelectBtn) {
        cancelSelectBtn.addEventListener('click', () => exitFlashcardSelectMode3D());
    }

    // ズームアウトボタンのイベントリスナーを即座に設定
    if (zoomOutBtn) {
      console.log('Setting up zoom out button event listener');
      zoomOutBtn.addEventListener('click', function () {
        console.log('Zoom out button clicked');
        console.log('graphInstance:', graphInstance);
        if (graphInstance) {
          console.log('Attempting to zoom out');
          try {
            // グラフデータを取得して最適な距離を計算
            const graphData = graphInstance.graphData();
            if (graphData && graphData.nodes && graphData.nodes.length > 0) {
              // ノードの位置からグラフの範囲を計算
              let minX = Infinity, maxX = -Infinity;
              let minY = Infinity, maxY = -Infinity;
              let minZ = Infinity, maxZ = -Infinity;
              
              graphData.nodes.forEach(node => {
                if (node.x !== undefined && node.y !== undefined && node.z !== undefined) {
                  minX = Math.min(minX, node.x);
                  maxX = Math.max(maxX, node.x);
                  minY = Math.min(minY, node.y);
                  maxY = Math.max(maxY, node.y);
                  minZ = Math.min(minZ, node.z);
                  maxZ = Math.max(maxZ, node.z);
                }
              });
              
              // グラフのサイズを計算
              const graphWidth = maxX - minX;
              const graphHeight = maxY - minY;
              const graphDepth = maxZ - minZ;
              const graphSize = Math.max(graphWidth, graphHeight, graphDepth);
              
              // 最適なカメラ距離を計算（グラフサイズの2倍 + 余裕）
              const optimalDistance = Math.max(graphSize * 2, 400);
              
              console.log('Graph size:', graphSize, 'Optimal distance:', optimalDistance);
              
              // 計算された距離でカメラ位置を設定
              graphInstance.cameraPosition(
                { x: 0, y: 0, z: optimalDistance }, 
                { x: 0, y: 0, z: 0 }, 
                2000
              );
              graphInstance.controls().target.set(0, 0, 0);
              graphInstance.controls().update();
              console.log('Camera position set successfully with calculated distance');
            } else {
              // フォールバック: 固定距離
              graphInstance.cameraPosition({ x: 0, y: 0, z: 600 }, { x: 0, y: 0, z: 0 }, 2000);
              graphInstance.controls().target.set(0, 0, 0);
              graphInstance.controls().update();
              console.log('Camera position set successfully (fallback)');
            }
          } catch (error) {
            console.error('Error calculating optimal camera position:', error);
            // エラー時のフォールバック
            try {
              graphInstance.cameraPosition({ x: 0, y: 0, z: 800 }, { x: 0, y: 0, z: 0 }, 2000);
              graphInstance.controls().target.set(0, 0, 0);
              graphInstance.controls().update();
              console.log('Camera position set successfully (error fallback)');
            } catch (error2) {
              console.error('Error with fallback camera position:', error2);
            }
          }
        } else {
          console.log('graphInstance is not available');
        }
      });
    } else {
      console.log('Zoom out button not found');
    }


    
    function enterFlashcardSelectMode3D() {
      isSelectingFlashcards = true;
      selectControls.classList.remove('hidden');
      document.querySelector('.corner-btn-group').classList.remove('visible');
      selectedNodeIds = [];
      updateSelectedWordsList3D();
    }

    function exitFlashcardSelectMode3D() {
      isSelectingFlashcards = false;
      selectControls.classList.add('hidden');
      document.querySelector('.corner-btn-group').classList.add('visible');
      clearGlow(); // 終了時にもグローをクリア
    }

    if (createFlashcardsBtn) {
      createFlashcardsBtn.addEventListener('click', enterFlashcardSelectMode3D);
    }
    
    function getNodeById3D(id) {
        if (!graphDataCache) return null;
        return graphDataCache.nodes.find(n => n.id === id);
    }

    function updateFlashcardGlows3D() {
        if (!graphDataCache) return;
        const allNodes = graphDataCache.nodes;
        // まず、すべてのノードからグローを削除
        allNodes.forEach(node => {
            if (node.__threeObj) {
                const glow = node.__threeObj.children.find(child => child.name === 'glow');
                if (glow) node.__threeObj.remove(glow);
            }
        });
        // 次に、選択されたノードのみにグローを追加
        selectedNodeIds.forEach(id => {
            const node = allNodes.find(n => n.id === id);
            if(node) addGlow(node);
        });
    }

    function updateSelectedWordsList3D() {
      selectedWordsList.innerHTML = '';
      selectedNodeIds.forEach(id => {
        const node = nodes.find(n => n.id === id);
        if (node) {
          const item = document.createElement('div');
          item.className = 'selected-word-item';
          item.innerHTML = `<span class='word-label'>${node.name || node.label}</span><button class='remove-word-btn'>&times;</button>`;
          item.querySelector('.remove-word-btn').addEventListener('click', (e) => {
            e.stopPropagation();
            selectedNodeIds = selectedNodeIds.filter(nid => nid !== id);
            updateSelectedWordsList3D();
          });
          selectedWordsList.appendChild(item);
        }
      });
      updateFlashcardGlows3D();
    }
    
    function setup3DNodeSelection() {
      if (!graphInstance) return;
      graphInstance.onNodeClick(node => {
        if (isSelectingFlashcards) {
          if (selectedNodeIds.includes(node.id)) {
            selectedNodeIds = selectedNodeIds.filter(nid => nid !== node.id);
          } else {
            selectedNodeIds.push(node.id);
          }
          updateSelectedWordsList3D();
        } else {
          // この部分は通常の、単語帳以外の選択を処理
          clearGlow();
          if (node) selectedNodes.add(node);
          addGlow(node);
          // カメラ中央化ロジック...
          const distance = 40;
          const distRatio = 1 + distance/Math.hypot(node.x, node.y, node.z);
          graphInstance.cameraPosition(
              { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
              node,
              2000
          );
          // 単語帳モードでない場合も詳細オーバーレイを表示
          showNodeDetails3D(node.id);
        }
      });
    }

    // --- 詳細オーバーレイとその他の関数... ---
    function showNodeDetails3D(nodeId) {
        // 詳細オーバーレイを表示する既存のロジック...
    }

    function waitForGraphAndData() {
      if (graphInstance && graphInstance.graphData) {
        const data = graphInstance.graphData();
        if (data && data.nodes && data.nodes.length > 0) {
          graphDataCache = data;
          nodes = data.nodes; // ローカル`nodes`配列が設定されていることを確認
          setup3DNodeSelection();
        } else {
          setTimeout(waitForGraphAndData, 300);
        }
      } else {
        setTimeout(waitForGraphAndData, 300);
      }
    }
    waitForGraphAndData();

  </script>
  <script>
    // --- 3Dビュー機能統合（2Dから移植） ---
    const createSelectBtn = document.getElementById('create-flashcard-select');
    const addWordInput = document.getElementById('add-word-input');
    const addWordSuggestions = document.getElementById('add-word-suggestions');

    // --- 作成ボタン ---
    if (createSelectBtn) {
      createSelectBtn.addEventListener('click', async function () {
        if (selectedNodeIds.length < 2) {
          alert('2つ以上の単語を選択してください');
          return;
        }
        const nameInput = document.getElementById('flashcard-name');
        const name = nameInput.value.trim() || '新しい単語帳';
        const ids = selectedNodeIds.map(id => Number(id));
        try {
          const res = await fetch('/api/flashcards', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ ids, name })
          });
          if (res.ok) {
            window.location.href = '../flashcard/flashcard_menu.html';
          } else {
            alert('単語帳の保存に失敗しました');
            exitFlashcardSelectMode3D();
          }
        } catch (error) {
          console.error('Flashcard creation error:', error);
          alert('単語帳の保存に失敗しました');
          exitFlashcardSelectMode3D();
        }
      });
    }

    // --- 単語追加サジェスト ---
    if (addWordInput) {
      addWordInput.addEventListener('input', function () {
        const query = this.value.trim();
        if (!query) {
          addWordSuggestions.classList.add('hidden');
          addWordSuggestions.classList.remove('visible');
          return;
        }
        const suggestions = nodes.filter(node =>
          (node.label || node.name).toLowerCase().includes(query.toLowerCase()) &&
          !selectedNodeIds.includes(node.id)
        ).slice(0, 5);
        if (suggestions.length > 0) {
          addWordSuggestions.innerHTML = '';
          suggestions.forEach(node => {
            const suggestionItem = document.createElement('div');
            suggestionItem.className = 'suggestion-item';
            suggestionItem.textContent = node.label || node.name;
            suggestionItem.addEventListener('click', () => {
              if (!selectedNodeIds.includes(node.id)) {
                selectedNodeIds.push(node.id);
                updateSelectedWordsList3D();
              }
              addWordInput.value = '';
              addWordSuggestions.classList.add('hidden');
              addWordSuggestions.classList.remove('visible');
            });
            addWordSuggestions.appendChild(suggestionItem);
          });
          // ドロップダウンを入力欄の下に配置
          const rect = addWordInput.getBoundingClientRect();
          addWordSuggestions.style.left = rect.left + 'px';
          addWordSuggestions.style.top = (rect.bottom + window.scrollY) + 'px';
          addWordSuggestions.style.width = rect.width + 'px';
          addWordSuggestions.classList.remove('hidden');
          addWordSuggestions.classList.add('visible');
        } else {
          addWordSuggestions.classList.add('hidden');
          addWordSuggestions.classList.remove('visible');
        }
      });
      addWordInput.addEventListener('blur', function () {
        setTimeout(() => {
          addWordSuggestions.classList.add('hidden');
          addWordSuggestions.classList.remove('visible');
        }, 200);
      });
    }
  </script>
</body>
</html>