<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3Dネットワークグラフ</title>
  <link rel="stylesheet" href="3d.css">
</head>
<body>



  
  <!-- 2D表示ボタン -->
  <button id="view-2d" onclick="window.location.href='../main2D/index.html'">2D表示</button>
  
  <!-- 左下のボタングループ -->
  <div class="corner-btn-group">

    <button class="corner-btn" id="center-view-btn">中心表示</button>

  </div>
  
  <div id="3d-graph"></div>
  <script src="https://unpkg.com/3d-force-graph"></script>
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
    let graphInstance = null;

    // data.jsonを取得
    fetch('/api/data')
      .then(res => {
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        console.log('Data loaded successfully:', data);
        // importance値から色を計算する関数（2Dと同じ）
        function getColorFromImportance(importance) {
          const clampedImportance = Math.max(0, Math.min(100, importance));
          const ratio = clampedImportance / 100;
          const r = Math.round(180 + (75 * ratio));
          const g = Math.round(120 + (135 * ratio));
          const b = Math.round(60 + (195 * ratio));
          return `rgb(${r}, ${g}, ${b})`;
        }

        // 3d-force-graph用に変換
        const graphData = {
          nodes: data.nodes.map(n => ({
            id: n.id,
            name: n.label,
            val: n.importance || 1,
            category: n.category || '',
            color: getColorFromImportance(n.importance || 50) // 2Dと同じ色分けルール
          })),
          links: data.edges.map(e => ({ source: e.from, target: e.to }))
        };

        // カラーパレット
        const starColors = ['#fffbe6', '#ffeedd', '#b5e3ff', '#7ecfff', '#fff', '#ffd6e6', '#ffe4b5', '#c7eaff'];

        // 3Dグラフ描画
        graphInstance = ForceGraph3D()(document.getElementById('3d-graph'))
          .graphData(graphData)
          .nodeLabel('name')
          .nodeThreeObject(node => {
            // 星っぽい球体＋発光エフェクト
            const group = new THREE.Group();
            const color = node.color || starColors[Math.floor(Math.random() * starColors.length)];
            const radius = Math.min(1.5 + (node.val || 1) * 0.7, 6); // サイズ制限
            // 球体
            const geometry = new THREE.SphereGeometry(radius, 24, 24);
            const material = new THREE.MeshBasicMaterial({ color });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            // 発光（glow）
            const glowMaterial = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.18 });
            const glow = new THREE.Mesh(new THREE.SphereGeometry(radius * 1.7, 24, 24), glowMaterial);
            group.add(glow);
            
            // テキストラベルを追加
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.font = 'bold 24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(node.name || node.id, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 5, 1);
            sprite.position.set(0, radius + 8, 0);
            group.add(sprite);
            
            return group;
          })
          .nodeThreeObjectExtend(true)
          .nodeColor(node => node.color)
          .linkOpacity(0.35)
          .linkColor(() => '#b5e3ff')
          .backgroundColor('#0a1020');

        // カメラを原点に固定し、常に原点を注視
        graphInstance.cameraPosition({ x: 0, y: 0, z: 200 }, { x: 0, y: 0, z: 0 }, 0);
        graphInstance.controls().target.set(0, 0, 0);
        graphInstance.controls().update();

        // 背景に星を追加（canvasにランダムな点を描画）
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * canvas.width;
              const y = Math.random() * canvas.height;
              const r = Math.random() * 0.7 + 0.3;
              ctx.save();
              ctx.globalAlpha = Math.random() * 0.5 + 0.3;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, 2 * Math.PI);
              ctx.fillStyle = starColors[Math.floor(Math.random() * starColors.length)];
              ctx.shadowColor = '#fff';
              ctx.shadowBlur = 4;
              ctx.fill();
              ctx.restore();
            }
          }
        }, 1000);
      })
      .catch(error => {
        console.error('Error loading data:', error);
        document.getElementById('3d-graph').innerHTML = `
          <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #f7c873; font-size: 1.2rem;">
            <div style="text-align: center;">
              <h3>データの読み込みに失敗しました</h3>
              <p>${error.message}</p>
              <p>バックエンドサーバーが起動しているか確認してください</p>
            </div>
          </div>
        `;
      });



    // 中心表示ボタン
    document.getElementById('center-view-btn').addEventListener('click', function() {
      centerView();
    });

    // ボタングループを表示
    document.querySelector('.corner-btn-group').classList.add('visible');





    function centerView() {
      if (!graphInstance) return;
      
      // カメラを原点に移動し、全ノードが見えるようにズームアウト
      graphInstance.cameraPosition({ x: 0, y: 0, z: 200 }, { x: 0, y: 0, z: 0 }, 1000);
      graphInstance.controls().target.set(0, 0, 0);
      graphInstance.controls().update();
      
      console.log('3Dビューを中心に移動しました');
    }
  </script>
</body>
</html> 