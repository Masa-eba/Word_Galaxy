<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>3Dネットワークグラフ</title>
  <style>
    html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background: #181a1b; }
    #3d-graph { width: 100vw; height: 100vh; }
    /* ボタンを垂直に並べる */
    .corner-btn-group {
      position: fixed;
      left: 2rem;
      right: auto;
      bottom: 2rem;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 1.5rem;
      z-index: 9999;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .corner-btn-group.visible {
      opacity: 1;
    }

    .corner-btn {
      width: 200px;
      height: 56px;
      border-radius: 50px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      padding: 0;
      margin: 0;
      font-size: 1.1rem;
      font-family: 'Segoe UI', 'Meiryo', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', Arial, Helvetica, sans-serif;
      font-weight: 400;
      opacity: 0.85;
      background: #2d313a;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s, background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .corner-btn:hover {
      opacity: 1;
      background: #3a3f4b;
    }
    .page-title {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      color: #f7c873;
      font-size: 1.5rem;
      font-weight: bold;
      z-index: 10;
      text-shadow: 0 0 10px rgba(247, 200, 115, 0.5);
    }
    
    /* 2D表示ボタン（ページタイトルの上に配置） */
    #view-2d {
      position: fixed !important;
      bottom: 5rem !important;
      right: 2rem !important;
      left: auto !important;
      margin: 0 !important;
      width: 200px;
      height: 56px;
      border-radius: 50px;
      box-shadow: 0 2px 12px rgba(0, 0, 0, 0.15);
      padding: 0;
      font-size: 1.1rem;
      font-family: 'Segoe UI', 'Meiryo', 'Hiragino Kaku Gothic ProN', 'Yu Gothic', Arial, Helvetica, sans-serif;
      font-weight: 400;
      opacity: 0.85;
      background: #2d313a;
      color: #fff;
      border: none;
      cursor: pointer;
      transition: opacity 0.2s, background 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      z-index: 9999;
    }

    #view-2d:hover {
      opacity: 1;
      background: #3a3f4b;
    }
  </style>
</head>
<body>
  <!-- BGM用のaudio要素 -->
  <audio id="bgm" loop>
    <source src="music/word-gragh.mp3" type="audio/mpeg">
    お使いのブラウザは音声再生をサポートしていません。
  </audio>

  <div class="page-title">3D ネットワークビュー</div>
  
  <!-- 2D表示ボタン（ページタイトルの上に独立配置） -->
  <button id="view-2d" onclick="window.location.href='index.html'">2D表示</button>
  
  <!-- 左下のボタングループ -->
  <div class="corner-btn-group">
    <button class="corner-btn" id="toggle-orbit-btn">公転ON</button>
    <button class="corner-btn" id="center-view-btn">中心表示</button>
    <button class="corner-btn" id="toggle-bgm-btn">停止中</button>
  </div>
  
  <div id="3d-graph"></div>
  <script src="https://unpkg.com/3d-force-graph"></script>
  <script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
  <script>
    let graphInstance = null;
    let isOrbiting = false;
    let orbitInterval = null;
    let originalPositions = null;
    let theta = 0;

    // data.jsonを取得
    fetch('/api/data')
      .then(res => {
        if (!res.ok) {
          throw new Error(`HTTP error! status: ${res.status}`);
        }
        return res.json();
      })
      .then(data => {
        console.log('Data loaded successfully:', data);
        // 3d-force-graph用に変換
        const graphData = {
          nodes: data.nodes.map(n => ({
            id: n.id,
            name: n.label,
            val: n.importance || 1,
            category: n.category || '',
            color: n.category === '基礎理論' ? '#fffbe6' : n.category === 'ネットワーク技術' ? '#7ecfff' : '#ffd6e6'
          })),
          links: data.edges.map(e => ({ source: e.from, target: e.to }))
        };

        // カラーパレット
        const starColors = ['#fffbe6', '#ffeedd', '#b5e3ff', '#7ecfff', '#fff', '#ffd6e6', '#ffe4b5', '#c7eaff'];

        // 3Dグラフ描画
        graphInstance = ForceGraph3D()(document.getElementById('3d-graph'))
          .graphData(graphData)
          .nodeLabel('name')
          .nodeThreeObject(node => {
            // 星っぽい球体＋発光エフェクト
            const group = new THREE.Group();
            const color = node.color || starColors[Math.floor(Math.random() * starColors.length)];
            const radius = Math.min(1.5 + (node.val || 1) * 0.7, 6); // サイズ制限
            // 球体
            const geometry = new THREE.SphereGeometry(radius, 24, 24);
            const material = new THREE.MeshBasicMaterial({ color });
            const sphere = new THREE.Mesh(geometry, material);
            group.add(sphere);
            // 発光（glow）
            const glowMaterial = new THREE.MeshBasicMaterial({ color, transparent: true, opacity: 0.18 });
            const glow = new THREE.Mesh(new THREE.SphereGeometry(radius * 1.7, 24, 24), glowMaterial);
            group.add(glow);
            
            // テキストラベルを追加
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 64;
            
            context.font = 'bold 24px Arial';
            context.fillStyle = '#ffffff';
            context.textAlign = 'center';
            context.fillText(node.name || node.id, 128, 32);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(20, 5, 1);
            sprite.position.set(0, radius + 8, 0);
            group.add(sprite);
            
            return group;
          })
          .nodeThreeObjectExtend(true)
          .nodeColor(node => node.color)
          .linkOpacity(0.35)
          .linkColor(() => '#b5e3ff')
          .linkDirectionalParticles(2)
          .linkDirectionalParticleWidth(2)
          .linkDirectionalParticleColor(() => '#fff')
          .backgroundColor('#0a1020');

        // カメラを原点に固定し、常に原点を注視
        graphInstance.cameraPosition({ x: 0, y: 0, z: 200 }, { x: 0, y: 0, z: 0 }, 0);
        graphInstance.controls().target.set(0, 0, 0);
        graphInstance.controls().update();

        // 背景に星を追加（canvasにランダムな点を描画）
        setTimeout(() => {
          const canvas = document.querySelector('canvas');
          if (canvas) {
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * canvas.width;
              const y = Math.random() * canvas.height;
              const r = Math.random() * 0.7 + 0.3;
              ctx.save();
              ctx.globalAlpha = Math.random() * 0.5 + 0.3;
              ctx.beginPath();
              ctx.arc(x, y, r, 0, 2 * Math.PI);
              ctx.fillStyle = starColors[Math.floor(Math.random() * starColors.length)];
              ctx.shadowColor = '#fff';
              ctx.shadowBlur = 4;
              ctx.fill();
              ctx.restore();
            }
          }
        }, 1000);
      })
      .catch(error => {
        console.error('Error loading data:', error);
        document.getElementById('3d-graph').innerHTML = `
          <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #f7c873; font-size: 1.2rem;">
            <div style="text-align: center;">
              <h3>データの読み込みに失敗しました</h3>
              <p>${error.message}</p>
              <p>バックエンドサーバーが起動しているか確認してください</p>
            </div>
          </div>
        `;
      });

    // 公転ON/OFFボタン
    document.getElementById('toggle-orbit-btn').addEventListener('click', function() {
      if (isOrbiting) {
        stopOrbit();
      } else {
        startOrbit();
      }
    });

    // 中心表示ボタン
    document.getElementById('center-view-btn').addEventListener('click', function() {
      centerView();
    });

    // ボタングループを表示
    document.querySelector('.corner-btn-group').classList.add('visible');

    // 音楽再生機能
    const bgm = document.getElementById('bgm');
    const toggleBgmBtn = document.getElementById('toggle-bgm-btn');
    let isPlaying = false;

    toggleBgmBtn.addEventListener('click', function() {
      if (isPlaying) {
        bgm.pause();
        isPlaying = false;
        toggleBgmBtn.textContent = '停止中';
        console.log('音楽を停止しました');
      } else {
        bgm.play().then(() => {
          isPlaying = true;
          toggleBgmBtn.textContent = '再生中';
          console.log('音楽を再生しました');
        }).catch(error => {
          console.error('音楽再生エラー:', error);
        });
      }
    });

    function startOrbit() {
      if (!graphInstance || isOrbiting) return;
      isOrbiting = true;
      document.getElementById('toggle-orbit-btn').textContent = '公転OFF';
      // 初期座標を保存
      const nodes = graphInstance.graphData().nodes;
      if (!originalPositions) {
        originalPositions = nodes.map(n => ({ id: n.id, x: n.x || 0, y: n.y || 0, z: n.z || 0 }));
      }
      theta = 0;
      orbitInterval = setInterval(() => {
        theta += 0.01;
        // 中心を原点とする
        nodes.forEach((n, i) => {
          const orig = originalPositions[i];
          // 半径は元の距離を維持
          const r = Math.sqrt(orig.x * orig.x + orig.y * orig.y);
          const phi = Math.atan2(orig.y, orig.x) + theta;
          // z座標も少し揺らす
          const z = orig.z * Math.cos(theta * 0.5 + i);
          n.x = r * Math.cos(phi);
          n.y = r * Math.sin(phi);
          n.z = z;
        });
        graphInstance.refresh();
      }, 30);
    }

    function stopOrbit() {
      isOrbiting = false;
      document.getElementById('toggle-orbit-btn').textContent = '公転ON';
      if (orbitInterval) clearInterval(orbitInterval);
      // 元の位置に戻す
      if (graphInstance && originalPositions) {
        const nodes = graphInstance.graphData().nodes;
        nodes.forEach((n, i) => {
          const orig = originalPositions[i];
          n.x = orig.x;
          n.y = orig.y;
          n.z = orig.z;
        });
        graphInstance.refresh();
      }
    }

    function centerView() {
      if (!graphInstance) return;
      
      // カメラを原点に移動し、全ノードが見えるようにズームアウト
      graphInstance.cameraPosition({ x: 0, y: 0, z: 200 }, { x: 0, y: 0, z: 0 }, 1000);
      graphInstance.controls().target.set(0, 0, 0);
      graphInstance.controls().update();
      
      console.log('3Dビューを中心に移動しました');
    }
  </script>
</body>
</html> 